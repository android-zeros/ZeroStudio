
一、核心原理：环境欺骗 (Environment Deception)

Android UI 框架在绘制任何界面之前，都依赖于一个核心概念：Context (上下文)。Context 是一个接口，它提供了关于应用环境的全局信息，其中最关键的就是 Resources 对象，而 Resources 对象又包含了描述屏幕物理特性的 DisplayMetrics。

DisplayMetrics 包含：

widthPixels, heightPixels: 屏幕的原始像素尺寸。

density: 屏幕密度（一个比例因子）。

densityDpi: 每英寸的点数 (DPI)。

scaledDensity: 用于字体缩放的密度。

所有 dp 到 px 的转换、sp 到 px 的转换、match_parent 的尺寸计算、ConstraintLayout 的约束求解，其最底层的“真理”来源都是 Context 提供的 DisplayMetrics。

我们的方案本质就是：创建一个“伪造”的 Context，用我们模拟的 DisplayMetrics 替换掉真实的 DisplayMetrics，然后将这个“被欺骗”的 Context 交给 Android 的布局渲染系统。

这样，整个渲染流程从源头上就被引导到了我们的模拟环境中，从而实现了完美的等价模拟。

二、方案的两个基石：内部计算等价性 & 外部显示等价性

为了实现一个无懈可击的模拟，必须同时满足以下两个条件：

基石 A: 内部计算等价性 (Internal Calculation Equivalence)

确保布局在测量(measure)和布局(layout)阶段，所有计算结果与真实的目标设备完全一致。

实现方式: 使用 Context.createConfigurationContext(Configuration)。

逻辑关系:

我们不直接修改 DisplayMetrics，因为这是不安全且不全面的做法。

我们创建一个全新的 Configuration 对象。这是一个高级的数据结构，不仅包含 densityDpi，还包含 screenWidthDp、screenHeightDp、orientation 等，这些都是系统进行资源选择（例如加载 layout-sw600dp 目录下的布局）的依据。

调用 createConfigurationContext API，系统会为我们生成一个全新的、隔离的 Context。这个新 Context 内部的 Resources 和 DisplayMetrics 已经完全根据我们提供的 Configuration 进行了重构。

从这个新 Context 中获取的 LayoutInflater 在解析 XML 时，会使用这个伪造的 DisplayMetrics，从而保证所有计算的等价性。

基石 B: 外部显示等价性 (External Display Equivalence)

确保经过“内部计算”得到的、具有特定像素尺寸的 View，能够在宿主设备（真机）的屏幕上，以 1:1 的像素比例被渲染出来。

实现方式: 在将模拟 View 添加到画布（Canvas）时，明确指定其 LayoutParams 的 width 和 height 为模拟的像素值。

逻辑关系:

经过基石 A 的处理，我们得到的 simulatedView 在 onMeasure 之后，其 getMeasuredWidth() 和 getMeasuredHeight() 的返回值就是我们模拟的像素尺寸（例如 1480 和 720）。

当我们创建一个 FrameLayout.LayoutParams(1480, 720) 并应用给 simulatedView 时，我们是在告诉 FrameLayout（画布）：“请为这个子 View 分配一块精确到像素的 1480px * 720px 的区域”。

由于 LayoutParams 的单位是像素，这个指令是绝对的，不受宿主设备屏幕密度的影响。宿主设备只会忠实地在屏幕上点亮一个 1480x720 的像素矩阵来绘制这个 View。

三、数学计算与方程式解析

这是方案的核心，证明了 dp 和 sp 的转换是如何被我们控制的。

基础方程式：

像素 (px) 与 密度无关像素 (dp) 的转换：
px = dp * density
其中，density = dpi / 160 (DENSITY_DEFAULT)

像素 (px) 与 可缩放像素 (sp) 的转换：
px = sp * scaledDensity
其中，scaledDensity 约等于 density，但会受到用户系统字体大小设置的影响。

场景对比：

假设我们有一个控件 android:layout_width="100dp" 和 android:textSize="20sp"。

参数	宿主设备 (真机)	模拟环境 (我们创建的)
屏幕尺寸 (px)	2048 x 1080	1480 x 720
屏幕密度 (DPI)	440 dpi (假设)	320 dpi (我们设定)
Density 值	440 / 160 = 2.75	320 / 160 = 2.0
ScaledDensity 值	≈ 2.75	≈ 2.0
		
100dp 的计算宽度	100 * 2.75 = 275 px	100 * 2.0 = 200 px
20sp 的计算字号	20 * 2.75 = 55 px (约)	20 * 2.0 = 40 px (约)

分析：
如上表所示，在默认情况下，控件在真机上会被渲染为 275px 宽。但当我们使用 simulatedContext 加载后，同一个 100dp 被正确地解析成了 200px，这完全等价于一个 1480x720, 320dpi 的真实设备上的表现。数学上的一致性得到了保证。

四、逻辑关系与工作流 (Workflow)

graph TD
    subgraph "输入层"
        A[用户设定: ScreenParameters(widthPx=1480, heightPx=720, dpi=320)]
    end

    subgraph "基石 A: 内部计算环境构建"
        B[获取原始 Context] --> C{创建新的 Configuration};
        A --> C;
        C --> D[设置 overrideConfig.densityDpi = 320];
        D --> E[计算并设置 screenWidthDp = 1480 / (320/160) = 740];
        E --> F[计算并设置 screenHeightDp = 720 / (320/160) = 360];
        B & F --> G[simulatedContext = baseContext.createConfigurationContext(overrideConfig)];
        G --> H[inflater = LayoutInflater.from(simulatedContext)];
        H --> I[simulatedView = inflater.inflate(...)];
        I --> J{Android 框架内部执行 onMeasure/onLayout};
    end

    subgraph "计算结果"
        J --> K[simulatedView.getMeasuredWidth() 返回 1480px];
    end

    subgraph "基石 B: 外部显示精确渲染"
        L[获取画布 ViewGroup (FrameLayout)];
        K --> M[创建 LayoutParams(width=1480, height=720)];
        M --> N[simulatedView.setLayoutParams(...)];
        L & N --> O[canvas.addView(simulatedView)];
    end

    subgraph "最终输出"
        O --> P[在真机屏幕上, 渲染出一个 1480x720 物理像素的、内容完全符合模拟参数的视图];
    end
