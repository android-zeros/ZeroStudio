 Transmiting the whole project models over the communication streams results in a bad performance.
 * If the project is huge, the IDE may even run out of allocated memory.
 *
 * In the previous tooling API implementation, we used to fetch project models from Gradle, copy their
 * data to our own models, then send it to the client. This resulted in a bad performance and
 * increased memory usage. To overcome this, we keep a reference to the project models we get from
 * from the Android Gradle Plugin and compute only the requested information from those models.
 *
 * With LSP4J's JsonRpc implementation, it is not possible to create a delegate method in a
 * service which can accept parameters. What this means is that if a method is annotated with
 * [JsonDelegate][org.eclipse.lsp4j.jsonrpc.services.JsonDelegate], it cannot accept any parameters.
 *
 * As we cannot send the whole project model to the client for the reasons mentioned above, we use
 * another approach in this implementation. The client first selects the project it wants to fetch
 * information about. After this, when the delegate methods are called, it fetches the information
 * about the selected project.
 *
 * TODO(itsaky): Find a better approach to this issue.
 *
 
 
 
 可用的替代协议以下几种：
 
 gRPC (Google Remote Procedure Call)
 核心机制:
协议: 基于 HTTP/2，支持双向流、流控制、头部压缩等高级特性。
接口定义: 使用 Protocol Buffers (.proto 文件) 来定义服务接口和消息结构。.proto 文件是一种与语言无关的接口定义语言 (IDL)。
代码生成: protoc 编译器可以根据 .proto 文件自动生成客户端和服务端的代码存根（stubs），支持多种语言（Java, Kotlin, C++, Go, Python 等）。

集成成本: 需要引入新的依赖（grpc-java, protobuf-java），并重写所有的模型和服务接口为 .proto 格式。这是一个较大的重构工作。
调试相对复杂: 因为是二进制协议，不像 JSON 那样可读，需要专门的工具（如 grpcurl）来调试。


RSocket
核心机制:
协议: 应用层二进制协议，可以运行在 TCP, WebSocket 等多种传输层之上。
交互模型: 提供四种交互模型：Request-Response, Fire-and-Forget, Request-Stream, Channel (双向流)。
反应式: 设计初衷就是为了与 Project Reactor, RxJava 等反应式框架无缝集成。
劣势:
生态相对较新: 虽然在快速发展，但社区和工具链相比 gRPC 还不算那么成熟。


其它方案：
保留lsp4j
只不过需要放弃 JsonDelegate，完全使用 @JsonRequest



长期收益来说最佳应该是迁移到 gRPC，这样可以解决大型项目和大量的流输入输出的阻塞带来的性能和不支持大型项目问题

 官网：https://grpc.io/
 
 github开源：https://github.com/grpc
 https://github.com/grpc/grpc-java
 https://github.com/grpc/grpc
 首先kotlin语言的：https://github.com/grpc/grpc-kotlin
 或者服务器选kotlin grpc，客户端用grpc c
 
 其它：https://grpc.org.cn/docs/what-is-grpc/introduction/
 
 
 
 其它鸡汤式幻想：或许试试交叉协议？或许有用？
 
 JSON-RPC + gRPC 混合架构
 
 双通道，多通道？
 
 
 TODO：未来计划：第二代AndroidIDE tooling：全面迁移到gRPC，已改善当前瓶颈和缺点
 